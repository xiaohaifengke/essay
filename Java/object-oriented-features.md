# 面向对象之封装、继承、多态

## 学习面向对象准备
  - 区分面向对象和面向过程
  - 类和对象的区别
  - 局部变量和成员变量的区别
    - 定义位置不同
    - 在内存中的位置不同
    - 声明周期不同
    - 初始化不同
  - 基本类型和引用类型作为方法参数传递的差别
  
## 封装
  - 表现：
    1. 变量：使用 *private* 修饰
    1. 方法：对实现过程的封装
    2. 类：对方法和变量的封装
  - 好处：
    1. 提高了代码的复用性
    2. 隐藏了实现细节，还要对外提供可以访问的方式，便于调用者的使用。（这是核心之一，也可以理解为就是封装的概念）
    3. 提高了安全性
    
  - private 修饰符
  
    > 注意：私有仅仅是封装的体现形式而已
    
    private 修饰的成员只能在当前类中访问，其它类中无法直接访问。  
    类中不需要对外提供的内容都私有化，包括 *属性和方法*。  
    描述事物时，属性都可以私有化并提供 setXxx getXxx 方法对其进行访问。
    
  - this 关键字
  
    当前对象的引用。  
    可以在成员变量名前面加上 *this.* 来区别成员变量和局部变量

## 继承
  - 好处：
    1. 提高了代码的复用性、维护性，提高开发效率
    2. 继承使类与类之间产生了关系，提供了多态的前提
  - 弊端：
    1. 类与类之间的耦合度过高
  - 特点
    1. java中类只能够单继承，不能多继承，可以多层继承
    
  - 子父类中成员变量的特点
  
    > 若父类中的成员变量是非私有的，子类可以直接访问；若父类中的成员变量私有了，则子类不能直接访问。
    
    当子父类中出现了不同名成员变量时，这时访问没有任何问题。  
    当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字 *super* 来完成。 *super* 用来表示当前对象中包含的父类对象的引用空间。
    > 在子类中，访问父类中的成员变量的格式：  
      super.父类中的成员变量

  - 子父类中成员方法的特点
    - 特点：
      > 当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法；若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中的方法。
    
    - 成员方法的特殊情况——覆盖
    
      子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override *重写*、复写或者覆盖。
      
    - 重写需要注意的细节问题：
      - 权限要大于等于父类权限
      - 方法的返回值类型、方法名、参数列表都要一样
      - 父类私有的方法，子类不能够进行重写
      
## 抽象类
  - 抽象类的特点：
    1. 抽象类和抽象方法都需要被 *abstract* 修饰。抽象方法一定要定义在抽象类中。
    2. 抽象类不可以直接创建对象，原因：调用抽象方法没有意义。
    3. 只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。
    > 之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。
  
  - 抽象类的细节问题：
    1. 抽象类一定是个父类？  是
    2. 抽象类中是否可以不定义抽象方法？ 是，但会失去意义
    3. 抽象关键字 *abstract* 不可以和哪些关键字共存？  
      *private*：私有方法是无法继承到的，也不存在覆盖。而 abstract 和 private 一起使用修饰方法， abstract 几要去实现这个方法，而private 修饰的子类根本无法得到父类这个方法。互相矛盾。  
      *final*：  
      *static*：

## 接口
    接口是对类的需求描述
  - 好处：
    1. 扩展了功能
    2. 降低了耦合性
    
  - 接口和抽象类的区别
    
    - 相同点：
      - 都位于继承的顶端，用于被其它类实现或继承；
      - 都不能直接实例化对象；
      - 都包含抽象方法，其子类都必须覆写这些抽象方法。
      
    - 区别：
      - 抽象类为部分方法提供实现，避免子类重复实现这些方法，提高代码重用性；接口只能包含抽象方法；
      - 一个类只能继承一个直接父类（可能是抽象类），却可以实现多个接口（接口弥补了Java的单继承）。
    
    - 二者的选用：
      - 优先选用接口，尽量少用抽象类；
      - 需要定义子类的行为，又要为子类提供共性功能时才选用抽象类。

## 多态
    多态的体现为： 父类引用变量可以指向子类对象。  
    多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。
    在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。
    
  - 多态成员变量：（编译运行看左边）  
    当子父类中出现同名的成员变量时，多态调用该变量时：  
    编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。
    运行时期：也是调用引用型变量所属的类中的成员变量。
    
  - 多态成员方法：（编译看左边，运行看右边）  
    编译时期：参考的是引用型变量所属的类中是否有被调用的成员方法。没有，编译失败。
    运行时期：参考的是引用型变量所指向的对象所属的类，并运行对象所属的类中的成员方法。
    
  - **instanceof** 关键字
  
        使用格式：boolean b = obj instanceof ObjClass
    
  - 多态-转型
    - 基本数据类型转换
    
          整数 int 转换成小数 double
          int x = 3;
          double d = x;
          
          把小数 double 转换成 整数 int
          double d = 3.3;
          int x = (int) d;
    - 多态的转型分为向上转型与向下转型两种：
      - 向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。  
        使用格式：  
        
            父类类型 变量名= new 子类类型()；
            
      - 向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！  
        使用格式：  
        
            子类类型 变量名= (子类类型) 父类类型的变量；
            
    - 多态的好处与弊端
    
        　　当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。向上转型的好处是隐藏了子类类型，提高了代码的扩展性。  
        　　向上转型的弊端是只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。
        
## 总结

  - 封装：将数据以及相关的操作组织在一起，成为独立的构件。外部无法直接访问这些封装了的数据，从而保证了这些数据的正确性。
  封装的目的是为了内部数据表现形式和实现细节的隐藏，信息隐藏是为了减少系统各部分间的依赖性，各部分间必须通过明确的通道传送信息，也就是对象间的接口。
  这样一来，隐藏了部分内部的细节，极大方便系统的开发，维护和扩展。
  - 继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。一个新类可以从现有的类中派生，这个过程称为类的继承。
  新类继承了原始类的特性，新类称为原始类的派生类(子类)，而原始类称为新类的基类(父类)。派生类可以从它的基类那里继承方法和实例变量，并且派生类可以修改或增加新的方法使之更适合特殊的需求。
  继承性很好地解决了软件的可重用性问题。
  - 多态：多态是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。
  简单的说，就是允许类与类之间相同方法名的指针得以调用， 这样很好地解决了应用程序函数同名问题。
  实现多态，有二种方式，覆盖，重载。配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义。
