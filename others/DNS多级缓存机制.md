>【摘要】 上一篇文章我们在缓存架构中提到了DNS缓存，其作用是加速DNS的解析，今天我们详细讲解一下DNS缓存机制。大家都知道，DNS解析其实就是将人类可读的且认可的一个字符串名字（域名）翻译成一个计算机可读可处理的数字（IP地址）而已，本身并不参与通信，然而就是这么简单的查询动作，其背后却有我们意想不到的复杂的系统。我们先了解一下DNS的一些基础概念和解析流程，有助于我们了解本篇文章最核心的内容：“...

上一篇文章我们在缓存架构中提到了DNS缓存，其作用是加速DNS的解析，今天我们详细讲解一下DNS缓存机制。

大家都知道，DNS解析其实就是将人类可读的且认可的一个字符串名字（**域名**）翻译成一个计算机可读可处理的数字（**IP地址**）而已，本身并不参与通信，然而就是这么简单的查询动作，其背后却有我们意想不到的复杂的系统。

我们先了解一下DNS的一些基础概念和解析流程，有助于我们了解本篇文章最核心的内容：“DNS多级缓存系统”。

*· 01 ·*

**DNS基础概念**

DNS，是英文Domain Name System的简称，中文称之为“**域名系统**”。

学过计算机的人都知道，互联网主机之间通信是通过IP地址来互相访问，IP地址是点分十进制数，比如10.11.10.235，但这样的数字串对人类来说很难理解和记忆。于是，人们发明了DNS系统，使用人类可读、可理解的字符串来代替一堆堆数字。

比如，我们想要建一个销售鲜花的中文网站，申请了IP地址后，还需要申请域名，为了让大家一看就知道是有关鲜花的网站，可以取“鲜花”的拼音，如xianhua作为域名，这样一旦我们访问过一次，知道是销售鲜花的网站，下次如果要再次网购鲜花，就很容易通过鲜花的拼音字母来访问。

其实DNS本质是”**命名系统“**，为什么不叫“名字”而叫“域名”呢？这是因为在因特网的命名系统中使用了许多的“**域(domain)**”，因此就出现了“域名”这个名词。“域名系统”明确地指明这种系统是应用在因特网中。



*· 02 \*·**

**因特网的域名结构**

因为因特网规模很大，所以整个因特网只使用一个域名服务器是不可能的。因此，早在1983年因特网开始采用层次树状结构的命名方法，并使用了**分布式的域名系统DNS**。使用分布式系统的好处是：即使单个节点故障，也不会妨碍整个DNS系统的正常运行。

任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即**域名**(domain name)。这里，“域”(domain)是名字空间中一个可被管理的划分。

从语法上讲，每一个域名都是由**标签**(label)序列组成，而各标号之间用**点**(小数点)隔开。

 如下例子所示：

![640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](.\imgs\dns\aogjods)

这是中央电视台用于收发电子邮件的计算机的域名，它由三个标签组成，其中.com是顶级域名，cctv是二级域名，.mail是三级域名。

下图是因特网的树状结构的域名空间：

​    ![640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](.\imgs\dns\grehjdb)

*· 03 \*·**

**DNS基本解析流程**

我们有必要了解一下DNS基本的解析流程，我们以浏览器访问www.google.com为例：

- 首先从客户端浏览器缓存查找，找到www.google.com就直接访问对应的IP地址；
- 浏览器缓存如未找到对应的IP，操作系统会去检查自己的Host文件，如果从中没找到对应关系，会再到系统DNS缓存中查,如果缓存中有,就直接返回该域名所对应的IP；
- 如果本地计算机缓存中没有，则会向我们事先设置好的Local DNS服务器（**一般是由ISP运营商提供**）去请求（对应图中的步骤1），即所谓的“**递归查询**”，Local DNS服务器首先会到自身解析数据库中去查，如果找到就返回；没有找到会向根服务器(Root NS)发送询问请求（对应图中的步骤2）；
- 根服务器收到请求，发现后缀是.com,就会把com所在的NS服务器告诉Local DNS服务器（对应图中的步骤3），然后，Local DNS服务器就会去请求.com所在的NS服务器（对应图中的步骤4）；
- 当请求到达.com NS服务器时，.com服务器发现域名是在google这个域下的，就会把google所在的NS服务器再告诉Local DNS服务器；
- Local DNS服务器收到NS回复（对应图中的步骤5），去访问google域下的NS服务器（对应图中的步骤6）；
- Google这个域的NS服务器一看是要访问www，就直接找到了www对应的的IP，并把它丢给了Local DNS服务器（对应图中的步骤7）；
- Local DNS服务器收到最终解析后的IP地址，返回给客户端（End User）（对应图中的步骤8），浏览器最终通过该IP地址访问www.google.com（对应图中的步骤9）。

![640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](.\imgs\dns\ahrdrfhrecx)

**
**

*· 04 \*·**

**DNS多级缓存机制**

经过前面的一堆铺垫，我们现在讲解本篇文章最核心的内容：**DNS的多级缓存机制**。

我们试着思考一下，当我们在浏览器上输入需要访问的网站域名的时候，域名解析是开始访问互联网应用的第一步，如果这一步都需要花很长时间，那么，整个互联网的架构设计一定是失败的！

为了满足DNS的高效、快速的查询，整个DNS系统，需要按照分布式系统架构来设计，并且，前面提到的Local DNS查询服务器，它是离客户最近的DNS解析服务器，类似于CDN的边缘节点，**除了直接把域名解析的结果缓存起来，也会试图把整个分布式的DNS管理服务器的数据，按照树型组织集中缓存在本地，这就是所谓的多级缓存！**

比如缓存了 .com域名服务器的域名解析结果，这样就不需要到Root NS去查询，无形中**大幅降低了Root NS根管理服务器的流量压力**。只有在查询服务器把各级缓存全都遗忘的时候，才会从根部开始一次查询，而这次新的查询结束后，查询服务器又会把它记住，直到岁月导致的遗忘。

哈哈，以上通过文字解释了DNS多级缓存的机制，下面我们用图来进一步解释:

![640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](.\imgs\dns\dahcjjjsdf)

这张图展示了多级缓存系统的结构，在客户端系统中，有浏览器缓存、OS缓存来直接解析的机制，这样就减少了访问Local DNS服务器的网络和查询的开销，所以速度是最快的。

当客户端查询不到时，需要访问Local DNS服务器，Local DNS的多级域名缓存机制能够尽可能的减少Root NS等服务器的访问。

![640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](.\imgs\dns\fhdsdddfdf)

这张图展示了Local DNS的递归查询，递归查询其实是基于自身多级缓存的查询，如果缓存里没有，需要访问Root NS等域名服务器的时候，属于向上的迭代查询。

我们举例了当我们需要查询谷歌邮箱地址mail.google.com时的多级缓存查询：

1、首先查询mail.google.com,如果Local DNS有，就直接返回解析后的IP地址；

2、如果没有，在缓存中查询 .google.com，如果有，就去向上查询.google.com的域名服务器迭代返回结果；

3、如果没有，在缓存中查询 .com，如果有，就去向上查询 .com的域名服务器迭代返回结果；

4、如果没有，就执行ROOT开始的基本的迭代查询，当然这个是效率最低的查询。

接下来关于DNS缓存进一步讲解的文章中，我们会讲到DNS污染和安全防范方面的内容，谢谢大家捧场！